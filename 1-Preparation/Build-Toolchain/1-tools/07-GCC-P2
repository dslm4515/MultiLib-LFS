# Tools: GCC Pass 2
# Build & install as LFS

# GCC requires the GMP, MPFR and MPC packages. As these packages
# may not be included in your host distribution, they will be 
# built with GCC. Unpack each package into the GCC source 
# directory and rename the resulting directories so the GCC 
# build procedures will automatically use them: 
tar -xf ../pkgs/mpfr-4.2.2.tar.xz
mv -v mpfr-4.2.2 mpfr
tar -xf ../pkgs/gmp-6.3.0.tar.xz
mv -v gmp-6.3.0 gmp
tar -xf ../pkgs/mpc-1.3.1.tar.gz
mv -v mpc-1.3.1 mpc

# The following command will change the location of GCC's 
# default dynamic linker to use the one installed in /tools. 
# It also removes /usr/include from GCC's include search path. 
# Issue: 
for file in gcc/config/{linux,i386/linux{,64}}.h
do
  cp -uv $file{,.orig}
  sed -e 's@/lib\(64\)\?\(32\)\?/ld@/tools&@g' \
      -e 's@/usr@/tools@g' $file.orig > $file
  echo '
#undef STANDARD_STARTFILE_PREFIX_1
#undef STANDARD_STARTFILE_PREFIX_2
#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/"
#define STANDARD_STARTFILE_PREFIX_2 ""' >> $file
  touch $file.orig
done

# Set the default directory name for 64-bit libraries to “lib”
# with 32-bit libraries to "lib32"
sed -e '/m64=/s/lib64/lib/' \
    -e '/m32=/s/m32=.*/m32=..\/lib32$(call if_multiarch,:i386-linux-gnu)/' \
    -i.orig gcc/config/i386/t-linux64

# Make -mstackrealign a default for 32bit objects:
sed '/STACK_REALIGN_DEFAULT/s/0/(!TARGET_64BIT \&\& TARGET_SSE)/' \
      -i gcc/config/i386/i386.h

# The GCC documentation recommends building GCC in a dedicated 
# build directory: 
mkdir -v build
cd       build

# Set the build options
export  CARGS="--target=$LFS_TGT "
export CARGS+="--host=$LFS_TGT "
export CARGS+="--build=$(../config.guess) "
export CARGS+="--prefix=/tools "
export CARGS+="--with-glibc-version=2.42 "
export CARGS+="--with-local-prefix=/tools "
export CARGS+="--with-native-system-header-dir=/tools/include "
export CARGS+="--with-multilib-list=m64,m32 "
export CARGS+="--enable-multilib "
export CARGS+="--enable-default-pie "
export CARGS+="--enable-default-ssp " 
export CARGS+="--enable-initfini-array "
export CARGS+="--enable-languages=c,c++ "
export CARGS+="--disable-libsanitizer "
export CARGS+="--disable-libstdcxx-pch "
export CARGS+="--disable-bootstrap "
export CARGS+="--disable-libgomp "
export CARGS+="--disable-nls "

# Prepare GCC for compilation:
CC=$LFS_TGT-gcc         \
CXX=$LFS_TGT-g++        \
AR=$LFS_TGT-ar          \
RANLIB=$LFS_TGT-ranlib  \
../configure $CARGS

# Build
make

# Install
make install

# Create a full version of the internal header using a command that is 
# identical to what the GCC build system does in normal circumstances:
cd ..
cat gcc/limitx.h gcc/glimits.h gcc/limity.h > \
  `dirname $($LFS_TGT-gcc -print-libgcc-file-name)`/include/limits.h

# Create a symlink. Many programs and scripts run cc instead 
# of gcc, which is used to keep programs generic and 
# therefore usable on all kinds of UNIX systems where the 
# GNU C compiler is not always installed. Running cc leaves 
# the system administrator free to decide which C compiler 
# to install: 
ln -sv gcc /tools/bin/cc

# At this point, it is imperative to stop and ensure that the 
# basic functions (compiling and linking) of the new toolchain 
# are working as expected. To perform a sanity check, run the 
# following commands: 
echo 'int main(){}' > dummy.c
cc dummy.c
readelf -l a.out | grep ': /tools'

# If everything is working correctly, there should be no errors, 
# and the output of the last command will be of the form: 
# [Requesting program interpreter: /tools/lib64/ld-linux-x86-64.so.2]

# Next test 32-bit builds:
cc  -m32 dummy.c
readelf -l a.out | grep ': /tools'

# If everything is working correctly, there should be no errors, 
# and the output of the last command will be of the form:
# [Requesting program interpreter: /tools/lib/ld-linux.so.2]

# Once all is well, clean up the test files: 
rm -v dummy.c a.out
